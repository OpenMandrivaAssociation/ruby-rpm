diff -p -up ruby-rpm-1.2.3/ext/rpm/db.c.rpm46 BUILD/ruby-rpm-1.2.3/ext/rpm/db.c
--- ruby-rpm-1.2.3/ext/rpm/db.c.rpm46	2007-04-24 00:42:32.000000000 +0200
+++ ruby-rpm-1.2.3/ext/rpm/db.c	2009-09-08 13:44:45.000000000 +0200
@@ -7,6 +7,9 @@
 /* $Id: db.c 45 2004-06-04 15:11:20Z kazuhiko $ */
 
 #include "private.h"
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+#include "rpmdb_internal.h" /* from rpm-4.6.0-rc3/lib/rpmdb_internal.h */
+#endif
 
 VALUE rpm_cDB;
 VALUE rpm_cTransaction;
@@ -481,7 +484,7 @@ rpm_transaction_delete(VALUE trans, VALU
 		}
 	} else if ( rb_obj_is_kind_of(pkg, rpm_cDependency) ==Qfalse && 
                     rb_respond_to(pkg,rb_intern("name")) && rb_respond_to(pkg,rb_intern("version"))){
-		VALUE name = rb_funcall(pkg,rb_intern("name"),0);
+/* 		VALUE name = rb_funcall(pkg,rb_intern("name"),0); */
 		mi = rpm_db_init_iterator(db, INT2NUM(RPMDBI_LABEL),rb_funcall(pkg,rb_intern("name"),0));
 		rpm_mi_set_iterator_version(mi,rb_funcall(pkg,rb_intern("version"),0));
 	} else
@@ -504,6 +507,19 @@ rpm_transaction_delete(VALUE trans, VALU
 
 #if RPM_VERSION(4,1,0) <= RPM_VERSION_CODE
 
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+/* from rpm-4.6.0-rc3/lib/rpmps.c */
+struct rpmProblem_s {
+    char * pkgNEVR;
+    char * altNEVR;
+    fnpyKey key;
+    rpmProblemType type;
+    int ignoreProblem;
+    char * str1;
+    uint64_t num1;
+};
+#endif
+
 /* from rpm-4.2.1/lib/rpmps.c */
 static int
 sameProblem(const rpmProblem p1, const rpmProblem p2)
@@ -519,7 +535,11 @@ sameProblem(const rpmProblem p1, const r
     if (p1->str1)
 		if (p2->str1 && strcmp(p1->str1, p2->str1))
 			return 1;
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+    if (p1->num1 != p2->num1)
+#else
     if (p1->ulong1 != p2->ulong1)
+#endif
 		return 1;
 	
     return 0;
@@ -593,6 +613,15 @@ package_new_from_NEVR(const char* nevr)
 }
 #endif
 
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+/* from rpm-4.6.0-rc3/lib/rpmps.c */
+struct rpmps_s {
+    int numProblems;		/*!< Current probs array size. */
+    int numProblemsAlloced;	/*!< Allocated probs array size. */
+    rpmProblem *probs;		/*!< Array of pointers to specific problems. */
+    int nrefs;			/*!< Reference count. */
+};
+#endif
 
 VALUE
 rpm_transaction_check(VALUE trans)
diff -p -up ruby-rpm-1.2.3/ext/rpm/extconf.rb.rpm46 BUILD/ruby-rpm-1.2.3/ext/rpm/extconf.rb
--- ruby-rpm-1.2.3/ext/rpm/extconf.rb.rpm46	2007-03-21 23:36:20.000000000 +0100
+++ ruby-rpm-1.2.3/ext/rpm/extconf.rb	2009-09-08 13:46:20.000000000 +0200
@@ -19,9 +19,62 @@ def check_popt
   end
 end
 
+def rpm_version(maj, min, mic)
+  return (maj<<16) + (min<<8) + mic
+end
+
+def check_rpm
+  unless have_library('rpm') then
+    STDERR.puts "rpm library not found"
+    false
+  end
+  $libs = append_library($libs, 'rpm')
+
+  ver_str = `LANG=C rpm --version | cut -d' ' -f 3`
+  ver_str.chomp!
+  ver = ver_str.split(/[\.-]/)
+  $rpm_version_code = rpm_version(ver[0].to_i, ver[1].to_i, ver[2].to_i)
+  # TODO: zaki: strict checking is requires
+  $CFLAGS = "#{$CFLAGS} -DRPM_VERSION_CODE=#{$rpm_version_code}"
+
+  if $rpm_version_code < rpm_version(4, 6, 0) then
+    $libs = append_library($libs, 'rpmdb')
+  end
+
+  if have_header('rpmlib.h') and
+      have_library('rpmio') and
+      have_library('rpmbuild', 'getBuildTime') then
+    true
+  else
+    STDERR.puts "rpm library not found"
+    false
+  end
+end
+
 def check_db
   dir_config('db')
-  if have_library("db-4.2","db_version")
+  if rpm_version(4, 6, 0) <= $rpm_version_code then
+    if have_library("db-4.6", "db_version") then
+      return true
+    end
+    if have_library("db-4.7", "db_version")
+      return true
+    end
+    return false
+  end
+  if have_library("db-4.7", "db_version")
+    return true
+  end
+  if have_library("db-4.6", "db_version")
+    return true
+  end
+  if have_library("db-4.5", "db_version")
+    return true
+  end
+  if have_library("db-4.3", "db_version")
+    return true
+  end
+  if have_library("db-4.2", "db_version")
     return true
   end
   4.downto(2) do |i|
@@ -37,27 +90,6 @@ def check_db
   end
 end
 
-def check_rpm
-  return false unless check_db
-  $libs = append_library($libs, 'rpmdb')
-  $libs = append_library($libs, 'rpm')
-  if have_header('rpmlib.h') and
-      have_library('rpmio') and
-      have_library('rpmbuild', 'getBuildTime') then
-    true
-  else
-    STDERR.puts "rpm library not found"
-    false
-  end
-end
-
-def check_rpm_version
-  version_string=`LANG=C rpm --version| cut -d' ' -f 3`
-  ver=version_string.split(/\./)
-  # TODO: zaki: strict checking is requires
-  $CFLAGS="#{$CFLAGS} -DRPM_VERSION_CODE=#{(ver[0].to_i<<16) + (ver[1].to_i<<8) + (ver[2].to_i<<0)}"
-end
-
 def check_debug
   if ENV["RUBYRPM_DEBUG"] then
     puts "debug mode\n"
@@ -69,7 +101,7 @@ end
 
 exit unless check_popt
 exit unless check_rpm
-exit unless check_rpm_version
+exit unless check_db
 
 check_debug
 
diff -p -up ruby-rpm-1.2.3/ext/rpm/package.c.rpm46 BUILD/ruby-rpm-1.2.3/ext/rpm/package.c
--- ruby-rpm-1.2.3/ext/rpm/package.c.rpm46	2007-03-21 23:36:20.000000000 +0100
+++ ruby-rpm-1.2.3/ext/rpm/package.c	2009-09-08 13:44:45.000000000 +0200
@@ -8,6 +8,17 @@
 
 #include "private.h"
 
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+/* rpm-4.6.0-rc3/lib/header_internal.c */
+extern int headerAddEntry(Header h, rpmTag tag, rpmTagType type,
+		rpm_constdata_t p, rpm_count_t c);
+
+extern int headerAddOrAppendEntry(Header h, rpmTag tag, rpmTagType type,
+		rpm_constdata_t p, rpm_count_t c);
+
+extern int headerRemoveEntry(Header h, rpmTag tag);
+#endif
+
 char *stpcpy( char *dest, const char *source );
 
 VALUE rpm_cPackage;
@@ -39,8 +50,12 @@ package_free(Header hdr)
 		char *sigmd5;
 		VALUE signature;
 		VALUE p;
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+		sigmd5 = headerFormat(hdr, "%{sigmd5}", NULL);
+#else
 		sigmd5 = headerSprintf(hdr,"%{sigmd5}",
 				rpmTagTable, rpmHeaderFormats, NULL);
+#endif
 		if(strcmp(sigmd5,"(none)")!=0){
 			signature = INT2NUM(rb_intern(sigmd5));
 			st_delete(tbl,&signature,&p);
@@ -65,8 +80,12 @@ package_new_from_header(VALUE klass, Hea
 
 	if(tbl){
 		char *sigmd5;
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+		sigmd5 = headerFormat(hdr, "%{sigmd5}", NULL);
+#else
 		sigmd5 = headerSprintf(hdr,"%{sigmd5}",
 				rpmTagTable, rpmHeaderFormats, NULL);
+#endif
 		if(strcmp(sigmd5,"(none)")!=0){
 			signature = INT2NUM(rb_intern(sigmd5));
 			st_lookup(tbl,signature,&p);
@@ -175,7 +194,11 @@ package_s_load(VALUE klass, VALUE str)
 	Fseek(fd, 0, SEEK_SET);
 	hdr = headerRead(fd, HEADER_MAGIC_YES);
 	Fclose(fd);
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+	unlink(RSTRING(temp)->ptr);
+#else
 	Unlink(RSTRING(temp)->ptr);
+#endif
 
 	if (!hdr) {
 		rb_raise(rb_eArgError, "unable load RPM::Package");
@@ -190,11 +213,11 @@ package_s_load(VALUE klass, VALUE str)
 VALUE
 rpm_package_copy_tags(VALUE from,VALUE to,VALUE tags)
 {
-	int_32 *copy_tags;
+	int32_t *copy_tags;
 	int length = NUM2INT(rb_funcall(tags,rb_intern("length"),0));
 	int i;
 
-	copy_tags = ALLOCA_N(int_32,length);
+	copy_tags = ALLOCA_N(int32_t,length);
 	for (i=0;i<length;i++)
 		copy_tags[i] = NUM2INT(rb_ary_entry(tags, i));
 	headerCopyTags(RPM_HEADER(from),RPM_HEADER(to),copy_tags);
@@ -246,12 +269,12 @@ rpm_package_add_dependency(VALUE pkg,VAL
 VALUE
 rpm_package_add_int32(VALUE pkg,VALUE tag,VALUE val)
 {
-	int_32 v;
+	int32_t v;
 	if (TYPE(val) == T_FIXNUM) {
-		v = (int_32) FIX2LONG(val);
+		v = (int32_t) FIX2LONG(val);
 	}
 	else if (TYPE(val) == T_BIGNUM) {
-		v = (int_32) NUM2LONG(val);
+		v = (int32_t) NUM2LONG(val);
 	}
 	else {
 		rb_raise(rb_eTypeError, "illegal argument type");
@@ -309,14 +332,19 @@ rpm_package_aref(VALUE pkg, VALUE tag)
 	VALUE val = Qnil;
 	void* data;
 	rpmTagType type;
-	int_32 count;
+	int32_t count;
 	register int i;
-	register const char* p;
+/* 	register const char* p; */
 	int ary_p = 0;
 	int i18n_p = 0;
 
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+	if (!headerGetEntryMinMemory(RPM_HEADER(pkg), tagval, (rpmTagType*)&type,
+									 (rpm_data_t*)&data, (rpm_count_t*)&count)) {
+#else
 	if (!headerGetEntryMinMemory(RPM_HEADER(pkg), tagval, (hTYP_t)&type,
 									 (hPTR_t*)&data, (hCNT_t)&count)) {
+#endif
 		goto leave;
 	}
 	switch (tagval) {
@@ -358,33 +387,33 @@ rpm_package_aref(VALUE pkg, VALUE tag)
 	case RPM_CHAR_TYPE:
 	case RPM_INT8_TYPE:
 		if (count == 1 && !ary_p) {
-			val = INT2NUM(*(int_8*)data);
+			val = INT2NUM(*(int8_t*)data);
 		} else {
 			val = rb_ary_new();
 			for (i = 0; i < count; i++) {
-				rb_ary_push(val, INT2NUM(((int_8*)data)[i]));
+				rb_ary_push(val, INT2NUM(((int8_t*)data)[i]));
 			}
 		}
 		break;
 
 	case RPM_INT16_TYPE:
 		if (count == 1 && !ary_p) {
-			val = INT2NUM(*(int_16*)data);
+			val = INT2NUM(*(int16_t*)data);
 		} else {
 			val = rb_ary_new();
 			for (i = 0; i < count; i++) {
-				rb_ary_push(val, INT2NUM(((int_16*)data)[i]));
+				rb_ary_push(val, INT2NUM(((int16_t*)data)[i]));
 			}
 		}
 		break;
 
 	case RPM_INT32_TYPE:
 		if (count == 1 && !ary_p) {
-			val = INT2NUM(*(int_32*)data);
+			val = INT2NUM(*(int32_t*)data);
 		} else {
 			val = rb_ary_new();
 			for (i = 0; i < count; i++) {
-				rb_ary_push(val, INT2NUM(((int_32*)data)[i]));
+				rb_ary_push(val, INT2NUM(((int32_t*)data)[i]));
 			}
 		}
 		break;
@@ -408,11 +437,16 @@ rpm_package_aref(VALUE pkg, VALUE tag)
 			if (i18n_p) {
 				char** i18ntab;
 				rpmTagType i18nt;
-				int_32 i18nc;
+				int32_t i18nc;
 
 				if (!headerGetEntryMinMemory(
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+						RPM_HEADER(pkg), HEADER_I18NTABLE, (rpmTagType*)&i18nt,
+						(rpm_data_t*)&i18ntab, (rpm_count_t*)&i18nc)) {
+#else
 						RPM_HEADER(pkg), HEADER_I18NTABLE, (hTYP_t)&i18nt,
 						(hPTR_t*)&i18ntab, (hCNT_t)&i18nc)) {
+#endif
 					goto strary;
 				}
 
@@ -447,8 +481,12 @@ rpm_package_sprintf(VALUE pkg, VALUE fmt
 	const char *errstr = "(unknown error)";
 	const char *str;
 
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+	str = headerFormat(RPM_HEADER(pkg), StringValueCStr(fmt), &errstr);
+#else
 	str = headerSprintf(RPM_HEADER(pkg), StringValueCStr(fmt),
 			rpmTagTable, rpmHeaderFormats, &errstr);
+#endif
 	if (str == NULL) {
 		rb_raise(rb_eRuntimeError, "incorrect format: %s",
 				 errstr);
@@ -485,8 +523,12 @@ rpm_package_get_signature(VALUE pkg)
 
 	if (NIL_P(signature)) {
         	char *sigmd5;
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+		sigmd5 = headerFormat(RPM_HEADER(pkg), "%{sigmd5}", NULL);
+#else
 		sigmd5 = headerSprintf(RPM_HEADER(pkg),"%{sigmd5}",
 				rpmTagTable, rpmHeaderFormats, NULL);
+#endif
 		if(sigmd5[0]){
 			signature = INT2NUM(rb_intern(sigmd5));
 			rb_ivar_set(pkg, id_signature, signature);
@@ -586,23 +628,38 @@ rpm_package_get_dependency(VALUE pkg,int
 	register int i;
 
 	char **names,**versions;
-	int_32 *flags;
+	int32_t *flags;
 	rpmTagType nametype,versiontype,flagtype;
-	int_32 count;
+	int32_t count;
 
 	deps = rb_ary_new();
 
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+	if (!headerGetEntryMinMemory(RPM_HEADER(pkg), nametag, (rpmTagType*)&nametype,
+						 (rpm_data_t*)&names, (rpm_count_t*)&count)) {
+#else
 	if (!headerGetEntryMinMemory(RPM_HEADER(pkg), nametag, (hTYP_t)&nametype,
 						 (hPTR_t*)&names, (hCNT_t)&count)) {
+#endif
 		return deps;
 	}
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+	if (!headerGetEntryMinMemory(RPM_HEADER(pkg), versiontag, (rpmTagType*)&versiontype,
+						 (rpm_data_t*)&versions, (rpm_count_t*)&count)) {
+#else
 	if (!headerGetEntryMinMemory(RPM_HEADER(pkg), versiontag, (hTYP_t)&versiontype,
 						 (hPTR_t*)&versions, (hCNT_t)&count)) {
+#endif
 		release_entry(nametype, (void*)names);
 		return deps;
 	}
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+	if (!headerGetEntryMinMemory(RPM_HEADER(pkg), flagtag, (rpmTagType*)&flagtype,
+						 (rpm_data_t*)&flags, (rpm_count_t*)&count)) {
+#else
 	if (!headerGetEntryMinMemory(RPM_HEADER(pkg), flagtag, (hTYP_t)&flagtype,
 						 (hPTR_t*)&flags, (hCNT_t)&count)) {
+#endif
 		release_entry(nametype, (void*)names);
 		release_entry(versiontype, (void*)versions);
 		return deps;
@@ -650,21 +713,36 @@ rpm_package_get_changelog(VALUE pkg)
 
 	char **times,**names,**texts;
 	rpmTagType timetype,nametype,texttype;
-	int_32 count;
+	int32_t count;
 
 	cl = rb_ary_new();
 
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+	if (!headerGetEntryMinMemory(RPM_HEADER(pkg), RPMTAG_CHANGELOGTIME, (rpmTagType*)&timetype,
+						 (rpm_data_t*)&times, (rpm_count_t*)&count)) {
+#else
 	if (!headerGetEntryMinMemory(RPM_HEADER(pkg), RPMTAG_CHANGELOGTIME, (hTYP_t)&timetype,
 						 (hPTR_t*)&times, (hCNT_t)&count)) {
+#endif
 		return cl;
 	}
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+	if (!headerGetEntryMinMemory(RPM_HEADER(pkg), RPMTAG_CHANGELOGNAME, (rpmTagType*)&nametype,
+						 (rpm_data_t*)&names, (rpm_count_t*)&count)) {
+#else
 	if (!headerGetEntryMinMemory(RPM_HEADER(pkg), RPMTAG_CHANGELOGNAME, (hTYP_t)&nametype,
 						 (hPTR_t*)&names, (hCNT_t)&count)) {
+#endif
 		release_entry(timetype, (void*)times);
 		return cl;
 	}
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+	if (!headerGetEntryMinMemory(RPM_HEADER(pkg), RPMTAG_CHANGELOGTEXT, (rpmTagType*)&texttype,
+						 (rpm_data_t*)&texts, (rpm_count_t*)&count)) {
+#else
 	if (!headerGetEntryMinMemory(RPM_HEADER(pkg), RPMTAG_CHANGELOGTEXT, (hTYP_t)&texttype,
 						 (hPTR_t*)&texts, (hCNT_t)&count)) {
+#endif
 		release_entry(timetype, (void*)times);
 		release_entry(nametype, (void*)names);
 		return cl;
@@ -699,7 +777,11 @@ rpm_package_dump(VALUE pkg)
 	munmap(buf, size);
 
 	Fclose(fd);
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+	unlink(RSTRING(temp)->ptr);
+#else
 	Unlink(RSTRING(temp)->ptr);
+#endif
 
 	return dump;
 }
diff -p -up ruby-rpm-1.2.3/ext/rpm/private.h.rpm46 BUILD/ruby-rpm-1.2.3/ext/rpm/private.h
--- ruby-rpm-1.2.3/ext/rpm/private.h.rpm46	2007-03-21 23:36:20.000000000 +0100
+++ ruby-rpm-1.2.3/ext/rpm/private.h	2009-09-08 13:44:45.000000000 +0200
@@ -24,7 +24,9 @@
 #include <rpmlib.h>
 #include <rpmdb.h>
 #include <rpmbuild.h>
+#if RPM_VERSION_CODE < RPM_VERSION(4,6,0)
 #include <rpmmessages.h>
+#endif
 #if RPM_VERSION(4,1,0) <= RPM_VERSION_CODE
 #include <rpmts.h>
 #include <rpmps.h>
@@ -98,11 +100,25 @@ void Init_rpm_spec(void);
 /* version.c */
 void Init_rpm_version(void);
 
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+/* rpm-4.6.0-rc3/lib/header_internal.c */
+extern int headerGetEntryMinMemory(Header h, rpmTag tag,
+			rpmTagType * type,
+			rpm_data_t * p,
+			rpm_count_t * c);
+
+extern void * headerFreeData(rpm_data_t data, rpmTagType type);
+#endif
+
 static void inline
 get_entry(Header hdr, rpmTag tag, rpmTagType* type, void** ptr)
 {
 	if (!headerGetEntryMinMemory(
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+			hdr, tag, type, (rpm_data_t*)ptr, NULL)) {
+#else
 			hdr, tag, (hTYP_t)type, (hPTR_t*)ptr, NULL)) {
+#endif
 		*ptr = NULL;
 	}
 }
diff -p -up ruby-rpm-1.2.3/ext/rpm/rpm.c.rpm46 BUILD/ruby-rpm-1.2.3/ext/rpm/rpm.c
--- ruby-rpm-1.2.3/ext/rpm/rpm.c.rpm46	2007-03-21 23:36:20.000000000 +0100
+++ ruby-rpm-1.2.3/ext/rpm/rpm.c	2009-09-08 13:44:45.000000000 +0200
@@ -7,6 +7,9 @@
 /* $Id: rpm.c 9 2004-03-13 14:19:20Z zaki $ */
 
 #include "private.h"
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+#include <rpmlog.h>
+#endif
 
 VALUE rpm_mRPM;
 
@@ -204,6 +207,7 @@ Init_rpmmodule(void)
 	DEF_LOG(DEBUG);
 #undef DEF_LOG
 
+#if RPM_VERSION_CODE < RPM_VERSION(4,6,0)
 #define DEF_MESS(name) \
 	rb_define_const(rpm_mRPM, "MESS_"#name, INT2NUM(RPMMESS_##name))
 	DEF_MESS(DEBUG);
@@ -214,6 +218,7 @@ Init_rpmmodule(void)
 	DEF_MESS(FATALERROR);
 	DEF_MESS(QUIET);
 #undef DEF_MESS
+#endif
 
 #define DEFINE_DBI(name) \
 	rb_define_const(rpm_mRPM, "DBI_"#name, INT2NUM(RPMDBI_##name))
@@ -400,7 +405,9 @@ Init_rpmmodule(void)
 #define DEFINE_SENSE(name) \
 	rb_define_const(rpm_mRPM, "SENSE_"#name, INT2NUM(RPMSENSE_##name))
 	DEFINE_SENSE(ANY);
+#if RPM_VERSION_CODE < RPM_VERSION(4,6,0)
 	DEFINE_SENSE(SERIAL);
+#endif
 	DEFINE_SENSE(LESS);
 	DEFINE_SENSE(GREATER);
 	DEFINE_SENSE(EQUAL);
@@ -453,7 +460,9 @@ Init_rpmmodule(void)
 	DEF_PROB(OLDPACKAGE);
 	DEF_PROB(DISKSPACE);
 	DEF_PROB(DISKNODES);
+#if RPM_VERSION_CODE < RPM_VERSION(4,6,0)
 	DEF_PROB(BADPRETRANS);
+#endif
 #undef DEF_PROB
 
 #define DEF_CALLBACK(name) \
@@ -514,8 +523,10 @@ Init_rpmmodule(void)
 #if RPM_VERSION_CODE < RPM_VERSION(4,1,0)
 	DEF_TRANS_FLAG(CHAINSAW);
 #else
+#if RPM_VERSION_CODE < RPM_VERSION(4,6,0)
 	DEF_TRANS_FLAG(ANACONDA);
 #endif
+#endif
 /* NOMD5 is not in jbj's 4.4.6 any more - Mandriva uses that */
 #ifdef RPMTRANS_FLAG_NOMD5
 	DEF_TRANS_FLAG(NOMD5);
diff -p -up ruby-rpm-1.2.3/ext/rpm/rpmdb_internal.h.rpm46 BUILD/ruby-rpm-1.2.3/ext/rpm/rpmdb_internal.h
--- ruby-rpm-1.2.3/ext/rpm/rpmdb_internal.h.rpm46	2009-09-08 13:44:45.000000000 +0200
+++ ruby-rpm-1.2.3/ext/rpm/rpmdb_internal.h	2009-09-08 13:44:45.000000000 +0200
@@ -0,0 +1,676 @@
+#ifndef H_RPMDB_INTERNAL
+#define H_RPMDB_INTERNAL
+
+#include <assert.h>
+#include <db.h>
+
+#include <rpmsw.h>
+#include <rpmtypes.h>
+#include <rpmutil.h>
+
+/**
+ */
+typedef struct _dbiIndexItem * dbiIndexItem;
+
+/** \ingroup rpmdb
+ * A single element (i.e. inverted list from tag values) of a database.
+ */
+typedef struct _dbiIndexSet * dbiIndexSet;
+
+/**
+ */
+typedef struct _dbiIndex * dbiIndex;
+
+/* this will break if sizeof(int) != 4 */
+/** \ingroup dbi
+ * A single item from an index database (i.e. the "data returned").
+ * Note: In rpm-3.0.4 and earlier, this structure was passed by value,
+ * and was identical to the "data saved" structure below.
+ */
+struct _dbiIndexItem {
+    unsigned int hdrNum;		/*!< header instance in db */
+    unsigned int tagNum;		/*!< tag index in header */
+    unsigned int fpNum;			/*!< finger print index */
+};
+
+/** \ingroup dbi
+ * Items retrieved from the index database.
+ */
+struct _dbiIndexSet {
+    struct _dbiIndexItem * recs;	/*!< array of records */
+    unsigned int count;			/*!< number of records */
+    size_t alloced;			/*!< alloced size */
+};
+
+/** \ingroup dbi
+ * Private methods for accessing an index database.
+ */
+struct _dbiVec {
+    int dbv_major;			/*!< Berkeley db version major */
+    int dbv_minor;			/*!< Berkeley db version minor */
+    int dbv_patch;			/*!< Berkeley db version patch */
+
+/** \ingroup dbi
+ * Return handle for an index database.
+ * @param rpmdb		rpm database
+ * @param rpmtag	rpm tag
+ * @return		0 on success
+ */
+    int (*open) (rpmdb rpmdb, rpmTag rpmtag, dbiIndex * dbip);
+
+/** \ingroup dbi
+ * Close index database, and destroy database handle.
+ * @param dbi		index database handle
+ * @param flags		(unused)
+ * @return		0 on success
+ */
+    int (*close) (dbiIndex dbi, unsigned int flags);
+
+/** \ingroup dbi
+ * Flush pending operations to disk.
+ * @param dbi		index database handle
+ * @param flags		(unused)
+ * @return		0 on success
+ */
+    int (*sync) (dbiIndex dbi, unsigned int flags);
+
+/** \ingroup dbi
+ * Associate secondary database with primary.
+ * @param dbi		index database handle
+ * @param dbisecondary	secondary index database handle
+ * @param callback	create secondary key from primary (NULL if DB_RDONLY)
+ * @param flags		DB_CREATE or 0
+ * @return		0 on success
+ */
+    int (*associate) (dbiIndex dbi, dbiIndex dbisecondary,
+                int (*callback) (DB *, const DBT *, const DBT *, DBT *),
+                unsigned int flags);
+
+/** \ingroup dbi
+ * Return join cursor for list of cursors.
+ * @param dbi		index database handle
+ * @param curslist	NULL terminated list of database cursors
+ * @retval dbcp		address of join database cursor
+ * @param flags		DB_JOIN_NOSORT or 0
+ * @return		0 on success
+ */
+    int (*join) (dbiIndex dbi, DBC ** curslist, DBC ** dbcp,
+                unsigned int flags);
+
+/** \ingroup dbi
+ * Open database cursor.
+ * @param dbi		index database handle
+ * @param txnid		database transaction handle
+ * @retval dbcp		address of new database cursor
+ * @param dbiflags	DB_WRITECURSOR or 0
+ * @return		0 on success
+ */
+    int (*copen) (dbiIndex dbi, DB_TXN * txnid,
+			DBC ** dbcp, unsigned int dbiflags);
+
+/** \ingroup dbi
+ * Close database cursor.
+ * @param dbi		index database handle
+ * @param dbcursor	database cursor
+ * @param flags		(unused)
+ * @return		0 on success
+ */
+    int (*cclose) (dbiIndex dbi, DBC * dbcursor, unsigned int flags);
+
+/** \ingroup dbi
+ * Duplicate a database cursor.
+ * @param dbi		index database handle
+ * @param dbcursor	database cursor
+ * @retval dbcp		address of new database cursor
+ * @param flags		DB_POSITION for same position, 0 for uninitialized
+ * @return		0 on success
+ */
+    int (*cdup) (dbiIndex dbi, DBC * dbcursor, DBC ** dbcp,
+		unsigned int flags);
+
+/** \ingroup dbi
+ * Delete (key,data) pair(s) using db->del or dbcursor->c_del.
+ * @param dbi		index database handle
+ * @param dbcursor	database cursor (NULL will use db->del)
+ * @param key		delete key value/length/flags
+ * @param data		delete data value/length/flags
+ * @param flags		(unused)
+ * @return		0 on success
+ */
+    int (*cdel) (dbiIndex dbi, DBC * dbcursor, DBT * key, DBT * data,
+			unsigned int flags);
+
+/** \ingroup dbi
+ * Retrieve (key,data) pair using db->get or dbcursor->c_get.
+ * @param dbi		index database handle
+ * @param dbcursor	database cursor (NULL will use db->get)
+ * @param key		retrieve key value/length/flags
+ * @param data		retrieve data value/length/flags
+ * @param flags		(unused)
+ * @return		0 on success
+ */
+    int (*cget) (dbiIndex dbi, DBC * dbcursor, DBT * key, DBT * data,
+			unsigned int flags);
+
+/** \ingroup dbi
+ * Retrieve (key,data) pair using dbcursor->c_pget.
+ * @param dbi		index database handle
+ * @param dbcursor	database cursor
+ * @param key		secondary retrieve key value/length/flags
+ * @param pkey		primary retrieve key value/length/flags
+ * @param data		primary retrieve data value/length/flags
+ * @param flags		DB_NEXT, DB_SET, or 0
+ * @return		0 on success
+ */
+    int (*cpget) (dbiIndex dbi, DBC * dbcursor,
+		DBT * key, DBT * pkey, DBT * data, unsigned int flags);
+
+/** \ingroup dbi
+ * Store (key,data) pair using db->put or dbcursor->c_put.
+ * @param dbi		index database handle
+ * @param dbcursor	database cursor (NULL will use db->put)
+ * @param key		store key value/length/flags
+ * @param data		store data value/length/flags
+ * @param flags		(unused)
+ * @return		0 on success
+ */
+    int (*cput) (dbiIndex dbi, DBC * dbcursor, DBT * key, DBT * data,
+			unsigned int flags);
+
+/** \ingroup dbi
+ * Retrieve count of (possible) duplicate items using dbcursor->c_count.
+ * @param dbi		index database handle
+ * @param dbcursor	database cursor
+ * @param countp	address of count
+ * @param flags		(unused)
+ * @return		0 on success
+ */
+    int (*ccount) (dbiIndex dbi, DBC * dbcursor,
+			unsigned int * countp,
+			unsigned int flags);
+
+/** \ingroup dbi
+ * Is database byte swapped?
+ * @param dbi		index database handle
+ * @return		0 no
+ */
+    int (*byteswapped) (dbiIndex dbi);
+
+/** \ingroup dbi
+ * Save statistics in database handle.
+ * @param dbi		index database handle
+ * @param flags		retrieve statistics that don't require traversal?
+ * @return		0 on success
+ */
+    int (*stat) (dbiIndex dbi, unsigned int flags);
+};
+
+/** \ingroup dbi
+ * Describes an index database (implemented on Berkeley db3 functionality).
+ */
+struct _dbiIndex {
+    char * dbi_root;		/*!< chroot(2) component of path */
+    char * dbi_home;		/*!< directory component of path */
+    char * dbi_file;		/*!< file component of path */
+    char * dbi_subfile;
+    char * dbi_tmpdir;		/*!< temporary directory */
+
+    int	dbi_ecflags;		/*!< db_env_create flags */
+    int	dbi_cflags;		/*!< db_create flags */
+    int	dbi_oeflags;		/*!< common (db,dbenv}->open flags */
+    int	dbi_eflags;		/*!< dbenv->open flags */
+    int	dbi_oflags;		/*!< db->open flags */
+    int	dbi_tflags;		/*!< dbenv->txn_begin flags */
+
+    int	dbi_type;		/*!< db index type */
+    unsigned dbi_mode;		/*!< mode to use on open */
+    int	dbi_perms;		/*!< file permission to use on open */
+    long dbi_shmkey;		/*!< shared memory base key */
+    int	dbi_api;		/*!< Berkeley API type */
+
+    int	dbi_verify_on_close;
+    int	dbi_use_dbenv;		/*!< use db environment? */
+    int	dbi_permit_dups;	/*!< permit duplicate entries? */
+    int	dbi_no_fsync;		/*!< no-op fsync for db */
+    int	dbi_no_dbsync;		/*!< don't call dbiSync */
+    int	dbi_lockdbfd;		/*!< do fcntl lock on db fd */
+    int	dbi_temporary;		/*!< non-persistent */
+    int	dbi_debug;
+    int	dbi_byteswapped;
+
+    char * dbi_host;
+    unsigned long dbi_cl_timeout;
+    unsigned long dbi_sv_timeout;
+
+	/* dbenv parameters */
+    int	dbi_lorder;
+    /* XXX db-4.3.14 adds dbenv as 1st arg. */
+    void (*db_errcall) (void * dbenv, const char *db_errpfx, char *buffer);
+    FILE *	dbi_errfile;
+    char * dbi_errpfx;
+    int	dbi_verbose;
+    int	dbi_region_init;
+    int	dbi_tas_spins;
+	/* mpool sub-system parameters */
+    int	dbi_mmapsize;	/*!< (10Mb) */
+    int	dbi_cachesize;	/*!< (128Kb) */
+	/* lock sub-system parameters */
+    unsigned int dbi_lk_max;
+    unsigned int dbi_lk_detect;
+int dbi_lk_nmodes;
+unsigned char * dbi_lk_conflicts;
+	/* log sub-system parameters */
+    unsigned int dbi_lg_max;
+    unsigned int dbi_lg_bsize;
+	/* transaction sub-system parameters */
+    unsigned int dbi_tx_max;
+#if 0
+    int	(*dbi_tx_recover) (DB_ENV *dbenv, DBT *log_rec,
+				DB_LSN *lsnp, int redo, void *info);
+#endif
+	/* dbinfo parameters */
+    int	dbi_pagesize;		/*!< (fs blksize) */
+    void * (*dbi_malloc) (size_t nbytes);
+	/* hash access parameters */
+    unsigned int dbi_h_ffactor;	/*!< */
+    unsigned int (*dbi_h_hash_fcn) (DB *, const void *bytes,
+				unsigned int length);
+    unsigned int dbi_h_nelem;	/*!< */
+    unsigned int dbi_h_flags;	/*!< DB_DUP, DB_DUPSORT */
+    int (*dbi_h_dup_compare_fcn) (DB *, const DBT *, const DBT *);
+	/* btree access parameters */
+    int	dbi_bt_flags;
+    int	dbi_bt_minkey;
+    int	(*dbi_bt_compare_fcn) (DB *, const DBT *, const DBT *);
+    int	(*dbi_bt_dup_compare_fcn) (DB *, const DBT *, const DBT *);
+    size_t (*dbi_bt_prefix_fcn) (DB *, const DBT *, const DBT *);
+	/* recno access parameters */
+    int	dbi_re_flags;
+    int	dbi_re_delim;
+    unsigned int dbi_re_len;
+    int	dbi_re_pad;
+    char * dbi_re_source;
+	/* queue access parameters */
+    unsigned int dbi_q_extentsize;
+
+    rpmdb dbi_rpmdb;		/*!< the parent rpm database */
+    rpmTag dbi_rpmtag;	/*!< rpm tag used for index */
+    int	dbi_jlen;		/*!< size of join key */
+
+    DB * dbi_db;		/*!< Berkeley DB * handle */
+    DB_TXN * dbi_txnid;		/*!< Bekerley DB_TXN * transaction id */
+    void * dbi_stats;		/*!< Berkeley db statistics */
+
+    const struct _dbiVec * dbi_vec;	/*!< private methods */
+
+};
+
+/** \ingroup rpmdb
+ * Describes the collection of index databases used by rpm.
+ */
+struct rpmdb_s {
+    char 	* db_root;/*!< path prefix */
+    char 	* db_home;/*!< directory path */
+    int		db_flags;
+    int		db_mode;	/*!< open mode */
+    int		db_perms;	/*!< open permissions */
+    int		db_api;		/*!< Berkeley API type */
+    char 	* db_errpfx;
+    int		db_remove_env;
+    int		db_filter_dups;
+    int		db_chrootDone;	/*!< If chroot(2) done, ignore db_root. */
+    void (*db_errcall) (const char *db_errpfx, char *buffer);
+    FILE *	db_errfile;
+    void * (*db_malloc) (size_t nbytes);
+    void * (*db_realloc) (void * ptr,
+						size_t nbytes);
+    void (*db_free) (void * ptr);
+    unsigned char * db_bits;	/*!< package instance bit mask. */
+    int		db_nbits;	/*!< no. of bits in mask. */
+    rpmdb	db_next;
+    int		db_opens;
+    void *	db_dbenv;	/*!< Berkeley DB_ENV handle. */
+    int		db_ndbi;	/*!< No. of tag indices. */
+    dbiIndex * _dbi;		/*!< Tag indices. */
+
+    struct rpmop_s db_getops;
+    struct rpmop_s db_putops;
+    struct rpmop_s db_delops;
+
+    int nrefs;			/*!< Reference count. */
+};
+
+/* for RPM's internal use only */
+
+/** \ingroup rpmdb
+ */
+enum rpmdbFlags {
+	RPMDB_FLAG_JUSTCHECK	= (1 << 0),
+	RPMDB_FLAG_MINIMAL	= (1 << 1),
+	RPMDB_FLAG_CHROOT	= (1 << 2)
+};
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** \ingroup db3
+ * Return new configured index database handle instance.
+ * @param rpmdb		rpm database
+ * @param rpmtag	rpm tag
+ * @return		index database handle
+ */
+RPM_GNUC_INTERNAL
+dbiIndex db3New(rpmdb rpmdb, rpmTag rpmtag);
+
+/** \ingroup db3
+ * Destroy index database handle instance.
+ * @param dbi		index database handle
+ * @return		NULL always
+ */
+RPM_GNUC_INTERNAL
+dbiIndex db3Free( dbiIndex dbi);
+
+/** \ingroup db3
+ * Format db3 open flags for debugging print.
+ * @param dbflags		db open flags
+ * @param print_dbenv_flags	format db env flags instead?
+ * @return			formatted flags (malloced)
+ */
+RPM_GNUC_INTERNAL
+char * prDbiOpenFlags(int dbflags, int print_dbenv_flags);
+
+/** \ingroup dbi
+ * Return handle for an index database.
+ * @param db		rpm database
+ * @param rpmtag	rpm tag
+ * @param flags		(unused)
+ * @return		index database handle
+ */
+RPM_GNUC_INTERNAL
+dbiIndex dbiOpen(rpmdb db, rpmTag rpmtag,
+		unsigned int flags);
+
+/* FIX: vector annotations */
+/** \ingroup dbi
+ * Open a database cursor.
+ * @param dbi		index database handle
+ * @param txnid		database transaction handle
+ * @retval dbcp		returned database cursor
+ * @param flags		DB_WRITECURSOR if writing, or 0
+ * @return		0 on success
+ */
+static inline
+int dbiCopen(dbiIndex dbi, DB_TXN * txnid,
+		DBC ** dbcp, unsigned int flags)
+{
+    return (*dbi->dbi_vec->copen) (dbi, txnid, dbcp, flags);
+}
+
+/** \ingroup dbi
+ * Close a database cursor.
+ * @param dbi		index database handle
+ * @param dbcursor	database cursor
+ * @param flags		(unused)
+ * @return		0 on success
+ */
+static inline
+int dbiCclose(dbiIndex dbi, DBC * dbcursor, unsigned int flags)
+{
+    return (*dbi->dbi_vec->cclose) (dbi, dbcursor, flags);
+}
+
+/** \ingroup dbi
+ * Duplicate a database cursor.
+ * @param dbi		index database handle
+ * @param dbcursor	database cursor
+ * @retval dbcp		address of new database cursor
+ * @param flags		DB_POSITION for same position, 0 for uninitialized
+ * @return		0 on success
+ */
+static inline
+int dbiCdup(dbiIndex dbi, DBC * dbcursor, DBC ** dbcp,
+		unsigned int flags)
+{
+    return (*dbi->dbi_vec->cdup) (dbi, dbcursor, dbcp, flags);
+}
+
+/** \ingroup dbi
+ * Delete (key,data) pair(s) from index database.
+ * @param dbi		index database handle
+ * @param dbcursor	database cursor (NULL will use db->del)
+ * @param key		delete key value/length/flags
+ * @param data		delete data value/length/flags
+ * @param flags		(unused)
+ * @return		0 on success
+ */
+static inline
+int dbiDel(dbiIndex dbi, DBC * dbcursor, DBT * key, DBT * data,
+		unsigned int flags)
+{
+    int rc;
+    assert(key->data != NULL && key->size > 0);
+    (void) rpmswEnter(&dbi->dbi_rpmdb->db_delops, 0);
+    rc = (dbi->dbi_vec->cdel) (dbi, dbcursor, key, data, flags);
+    (void) rpmswExit(&dbi->dbi_rpmdb->db_delops, data->size);
+    return rc;
+}
+
+/** \ingroup dbi
+ * Retrieve (key,data) pair from index database.
+ * @param dbi		index database handle
+ * @param dbcursor	database cursor (NULL will use db->get)
+ * @param key		retrieve key value/length/flags
+ * @param data		retrieve data value/length/flags
+ * @param flags		(unused)
+ * @return		0 on success
+ */
+static inline
+int dbiGet(dbiIndex dbi, DBC * dbcursor, DBT * key, DBT * data,
+		unsigned int flags)
+{
+    int rc;
+    assert((flags == DB_NEXT) || (key->data != NULL && key->size > 0));
+    (void) rpmswEnter(&dbi->dbi_rpmdb->db_getops, 0);
+    rc = (dbi->dbi_vec->cget) (dbi, dbcursor, key, data, flags);
+    (void) rpmswExit(&dbi->dbi_rpmdb->db_getops, data->size);
+    return rc;
+}
+
+/** \ingroup dbi
+ * Retrieve (key,data) pair using dbcursor->c_pget.
+ * @param dbi		index database handle
+ * @param dbcursor	database cursor (NULL will use db->get)
+ * @param key		secondary retrieve key value/length/flags
+ * @param pkey		primary retrieve key value/length/flags
+ * @param data		primary retrieve data value/length/flags
+ * @param flags		DB_NEXT, DB_SET, or 0
+ * @return		0 on success
+ */
+static inline
+int dbiPget(dbiIndex dbi, DBC * dbcursor,
+		DBT * key, DBT * pkey, DBT * data, unsigned int flags)
+{
+    int rc;
+    assert((flags == DB_NEXT) || (key->data != NULL && key->size > 0));
+    (void) rpmswEnter(&dbi->dbi_rpmdb->db_getops, 0);
+    rc = (dbi->dbi_vec->cpget) (dbi, dbcursor, key, pkey, data, flags);
+    (void) rpmswExit(&dbi->dbi_rpmdb->db_getops, (ssize_t) data->size);
+    return rc;
+}
+
+/** \ingroup dbi
+ * Store (key,data) pair in index database.
+ * @param dbi		index database handle
+ * @param dbcursor	database cursor (NULL will use db->put)
+ * @param key		store key value/length/flags
+ * @param data		store data value/length/flags
+ * @param flags		(unused)
+ * @return		0 on success
+ */
+static inline
+int dbiPut(dbiIndex dbi, DBC * dbcursor, DBT * key, DBT * data,
+		unsigned int flags)
+{
+    int rc;
+    assert(key->data != NULL && key->size > 0 && data->data != NULL && data->size > 0);
+    (void) rpmswEnter(&dbi->dbi_rpmdb->db_putops, (ssize_t) 0);
+    rc = (dbi->dbi_vec->cput) (dbi, dbcursor, key, data, flags);
+    (void) rpmswExit(&dbi->dbi_rpmdb->db_putops, (ssize_t) data->size);
+    return rc;
+}
+
+/** \ingroup dbi
+ * Retrieve count of (possible) duplicate items.
+ * @param dbi		index database handle
+ * @param dbcursor	database cursor
+ * @param countp	address of count
+ * @param flags		(unused)
+ * @return		0 on success
+ */
+static inline
+int dbiCount(dbiIndex dbi, DBC * dbcursor, unsigned int * countp,
+		unsigned int flags)
+{
+    return (*dbi->dbi_vec->ccount) (dbi, dbcursor, countp, flags);
+}
+
+/** \ingroup dbi
+ * Verify (and close) index database.
+ * @param dbi		index database handle
+ * @param flags		(unused)
+ * @return		0 on success
+ */
+static inline
+int dbiVerify(dbiIndex dbi, unsigned int flags)
+{
+    dbi->dbi_verify_on_close = 1;
+    return (*dbi->dbi_vec->close) (dbi, flags);
+}
+
+/** \ingroup dbi
+ * Close index database.
+ * @param dbi		index database handle
+ * @param flags		(unused)
+ * @return		0 on success
+ */
+static inline
+int dbiClose(dbiIndex dbi, unsigned int flags)
+{
+    return (*dbi->dbi_vec->close) (dbi, flags);
+}
+
+/** \ingroup dbi
+ * Flush pending operations to disk.
+ * @param dbi		index database handle
+ * @param flags		(unused)
+ * @return		0 on success
+ */
+static inline
+int dbiSync (dbiIndex dbi, unsigned int flags)
+{
+    return (*dbi->dbi_vec->sync) (dbi, flags);
+}
+
+/** \ingroup dbi
+ * Associate secondary database with primary.
+ * @param dbi		index database handle
+ * @param dbisecondary	secondary index database handle
+ * @param callback	create secondary key from primary (NULL if DB_RDONLY)
+ * @param flags		DB_CREATE or 0
+ * @return		0 on success
+ */
+static inline
+int dbiAssociate(dbiIndex dbi, dbiIndex dbisecondary,
+                int (*callback) (DB *, const DBT *, const DBT *, DBT *),
+                unsigned int flags)
+{
+    return (*dbi->dbi_vec->associate) (dbi, dbisecondary, callback, flags);
+}
+
+/** \ingroup dbi
+ * Return join cursor for list of cursors.
+ * @param dbi		index database handle
+ * @param curslist	NULL terminated list of database cursors
+ * @retval dbcp		address of join database cursor
+ * @param flags		DB_JOIN_NOSORT or 0
+ * @return		0 on success
+ */
+static inline
+int dbiJoin(dbiIndex dbi, DBC ** curslist, DBC ** dbcp,
+                unsigned int flags)
+{
+    return (*dbi->dbi_vec->join) (dbi, curslist, dbcp, flags);
+}
+
+/** \ingroup dbi
+ * Is database byte swapped?
+ * @param dbi		index database handle
+ * @return		0 same order, 1 swapped order
+ */
+static inline
+int dbiByteSwapped(dbiIndex dbi)
+{
+    if (dbi->dbi_byteswapped == -1)
+        dbi->dbi_byteswapped = (*dbi->dbi_vec->byteswapped) (dbi);
+    return dbi->dbi_byteswapped;
+}
+/** \ingroup dbi
+ * Is database byte swapped?
+ * @param dbi		index database handle
+ * @param flags		DB_FAST_STAT or 0
+ * @return		0 on success
+ */
+static inline
+int dbiStat(dbiIndex dbi, unsigned int flags)
+{
+    return (*dbi->dbi_vec->stat) (dbi, flags);
+}
+
+
+/** \ingroup dbi
+ * Destroy set of index database items.
+ * @param set	set of index database items
+ * @return	NULL always
+ */
+RPM_GNUC_INTERNAL
+dbiIndexSet dbiFreeIndexSet(dbiIndexSet set);
+
+/** \ingroup dbi
+ * Count items in index database set.
+ * @param set	set of index database items
+ * @return	number of items
+ */
+RPM_GNUC_INTERNAL
+unsigned int dbiIndexSetCount(dbiIndexSet set);
+
+/** \ingroup dbi
+ * Return record offset of header from element in index database set.
+ * @param set	set of index database items
+ * @param recno	index of item in set
+ * @return	record offset of header
+ */
+RPM_GNUC_INTERNAL
+unsigned int dbiIndexRecordOffset(dbiIndexSet set, int recno);
+
+/** \ingroup dbi
+ * Return file index from element in index database set.
+ * @param set	set of index database items
+ * @param recno	index of item in set
+ * @return	file index
+ */
+RPM_GNUC_INTERNAL
+unsigned int dbiIndexRecordFileNumber(dbiIndexSet set, int recno);
+
+#ifndef __APPLE__
+/**
+ *  * Mergesort, same arguments as qsort(2).
+ *   */
+RPM_GNUC_INTERNAL
+int mergesort(void *base, size_t nmemb, size_t size,
+                int (*cmp) (const void *, const void *));
+#else
+/* mergesort is defined in stdlib.h on Mac OS X */
+#endif /* __APPLE__ */
+
+#endif
diff -p -up ruby-rpm-1.2.3/ext/rpm/spec.c.rpm46 BUILD/ruby-rpm-1.2.3/ext/rpm/spec.c
--- ruby-rpm-1.2.3/ext/rpm/spec.c.rpm46	2007-03-21 23:36:20.000000000 +0100
+++ ruby-rpm-1.2.3/ext/rpm/spec.c	2009-09-08 13:44:45.000000000 +0200
@@ -66,7 +66,11 @@ spec_s_open(VALUE klass, VALUE filename)
 			break;
 		}
 
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+	case PART_ERROR:
+#else
 	case RPMERR_BADSPEC:
+#endif
 	default:
 		rb_raise(rb_eRuntimeError, "specfile `%s' parsing failed", RSTRING(filename)->ptr);
 	}
@@ -83,8 +87,13 @@ rpm_spec_open(const char* filename)
 VALUE
 rpm_spec_get_buildroot(VALUE spec)
 {
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+	if (RPM_SPEC(spec)->buildRoot) {
+		return rb_str_new2(RPM_SPEC(spec)->buildRoot);
+#else
 	if (RPM_SPEC(spec)->buildRootURL) {
 		return rb_str_new2(RPM_SPEC(spec)->buildRootURL);
+#endif
 	}
 	return Qnil;
 }
@@ -123,15 +132,21 @@ rpm_spec_get_buildrequires(VALUE spec)
 	if (NIL_P(br)) {
 		const char** names;
 		const char** vers;
-		int_32* flags;
-		int_32 count;
+		int32_t* flags;
+		int32_t count;
 		rpmTagType nt, vt, type;
 		register int i;
 
 		br = rb_ary_new();
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+		if (!headerGetEntryMinMemory(RPM_SPEC(spec)->buildRestrictions,
+									 RPMTAG_REQUIRENAME, (rpmTagType*)&nt,
+									 (rpm_data_t*)&names, (rpm_count_t*)&count)) {
+#else
 		if (!headerGetEntryMinMemory(RPM_SPEC(spec)->buildRestrictions,
 									 RPMTAG_REQUIRENAME, (hTYP_t)&nt,
 									 (hPTR_t*)&names, (hCNT_t)&count)) {
+#endif
 			goto leave;
 		}
 
@@ -163,15 +178,21 @@ rpm_spec_get_buildconflicts(VALUE spec)
 	if (NIL_P(bc)) {
 		const char** names;
 		const char** vers;
-		int_32* flags;
-		int_32 count;
+		int32_t* flags;
+		int32_t count;
 		rpmTagType nt, vt, type;
 		register int i;
 
 		bc = rb_ary_new();
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+		if (!headerGetEntryMinMemory(RPM_SPEC(spec)->buildRestrictions,
+									 RPMTAG_CONFLICTNAME, (rpmTagType*)&nt,
+									 (rpm_data_t*)&names, (rpm_count_t*)&count)) {
+#else
 		if (!headerGetEntryMinMemory(RPM_SPEC(spec)->buildRestrictions,
 									 RPMTAG_CONFLICTNAME, (hTYP_t)&nt,
 									 (hPTR_t*)&names, (hCNT_t)&count)) {
+#endif
 			goto leave;
 		}
 
diff -p -up ruby-rpm-1.2.3/ext/rpm/version.c.rpm46 BUILD/ruby-rpm-1.2.3/ext/rpm/version.c
--- ruby-rpm-1.2.3/ext/rpm/version.c.rpm46	2007-04-24 03:30:27.000000000 +0200
+++ ruby-rpm-1.2.3/ext/rpm/version.c	2009-09-08 13:44:45.000000000 +0200
@@ -29,7 +29,11 @@ parseEVR(char* evr, const char** ep, con
 	char* se;
 
 	s = evr;
+#if RPM_VERSION(4,6,0) <= RPM_VERSION_CODE
+	while (*s && risdigit(*s)) s++;	/* s points to epoch terminator */
+#else
 	while (*s && xisdigit(*s)) s++;	/* s points to epoch terminator */
+#endif
 	se = strrchr(s, '-');			/* se points to version terminator */
 
 	if (*s == ':') {
@@ -304,7 +308,7 @@ VALUE
 rpm_version_inspect(VALUE ver)
 {
 	char buf[BUFSIZ];
-	char *p = buf;
+/* 	char *p = buf; */
 	VALUE v, r, e;
 	v = rb_ivar_get(ver, id_v);
 	r = rb_ivar_get(ver, id_r);
